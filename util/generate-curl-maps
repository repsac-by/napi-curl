#!/usr/bin/node
'use strict';

const fs = require('fs');
const readline = require('readline');
const { spawnSync } = require('child_process');


(async () => {
	const version = curlVesrion();

	await Promise.all([ version, curlh() ]).then(createMaps);

})();

function curlVesrion () {
	const resp = spawnSync('pkg-config', [ '--modversion', 'libcurl' ]);
	if (resp.error)
		throw resp.error;

	if (resp.status !== 0)
		throw new Error('pkg-config return status:', resp.status);

	return resp.stdout.toString().trim();
}

function curlh () {
	const options = [];
	const infos = [];
	const codes = [];
	const infoRe = /^\s*CURLINFO_(\w+)\s*=[^C]*CURLINFO_(LONG|DOUBLE|OFF_T|STRING|SLIST)/;
	const curlCodeRe = /^\s*CURLE_(\w+),/;

	return new Promise(resolve =>
		readline.createInterface({
			input: fs.createReadStream('/usr/include/curl/curl.h'),
			crlfDelay: Infinity,
		}).on('line', line => {

			const i = infoRe.exec(line);
			if (i) {
				infos.push(`{ "${i[1]}", CURLINFO_${i[1]} }`);
				return;
			}

			const code = curlCodeRe.exec(line);
			if (code) {
				codes.push(`{ CURLE_${code[1]}, "CURLE_${code[1]}" }`);
				return;
			}
		}).on('close', () => resolve({ options, infos, codes })),
	);
}

function createMaps ([ version, { infos, codes } ]) {
	process.stdout.write(`\
// libcurl ${version}
#include <node/node_api.h>
#include <curl/curl.h>
#include <map>

std::map<std::string, CURLINFO> mapCURLinfo {
	${infos.join(',\n\t')}
};

std::map<CURLcode, std::string> mapCURLcode {
	${codes.join(',\n\t')}
};
`);
}
